// Code generated by protoc-gen-lightbrother, DO NOT EDIT.

/*
Package api is a generated gin stub package.
This code was generated with protoc-gen-lightbrother. 

It is generated from these files:
	user.proto
*/
package api

import (
	"github.com/gin-gonic/gin"
	"context"
	"net/http"
)

// to suppressed 'imported but not used warning'

const HTTP_METGOD = "GRPC"

var PathUserLogin = "/most.simple.mcd.User/login"
var PathUserLogout = "/most.simple.mcd.User/logout"
var PathUserInfo = "/most.simple.mcd.User/info"
var PathUserUpdate = "/most.simple.mcd.User/update"

// UserGinServer is the server API for User service.
type UserGinServer interface {
	// 用户登录
	Login(ctx context.Context, req *LoginReq) (resp *LoginResp, err error)

	// 用户注销
	Logout(ctx context.Context, req *LogoutReq) (resp *LogoutResp, err error)

	// 获取用户信息
	Info(ctx context.Context, req *InfoReq) (resp *InfoResp, err error)

	// 更新用户信息
	Update(ctx context.Context, req *UpdateReq) (resp *UpdateResp, err error)
}

var apiUserSvc UserGinServer

func login(c *gin.Context) {
	p := new(LoginResp)
	if err := c.BindJSON(p); err != nil {
		c.JSON(http.StatusInternalServerError, err)
	}
	resp, err := apiUserSvc.Login(c, p)
	if err != nil {
		c.Set("code", -500)
		c.Set("message", err.Error())
		c.JSON(http.StatusOK, getResponse(c, nil))
	}
	c.JSON(http.StatusOK, getResponse(c, resp))
}

func logout(c *gin.Context) {
	p := new(LogoutResp)
	if err := c.BindJSON(p); err != nil {
		c.JSON(http.StatusInternalServerError, err)
	}
	resp, err := apiUserSvc.Logout(c, p)
	if err != nil {
		c.Set("code", -500)
		c.Set("message", err.Error())
		c.JSON(http.StatusOK, getResponse(c, nil))
	}
	c.JSON(http.StatusOK, getResponse(c, resp))
}

func info(c *gin.Context) {
	p := new(InfoResp)
	if err := c.BindJSON(p); err != nil {
		c.JSON(http.StatusInternalServerError, err)
	}
	resp, err := apiUserSvc.Info(c, p)
	if err != nil {
		c.Set("code", -500)
		c.Set("message", err.Error())
		c.JSON(http.StatusOK, getResponse(c, nil))
	}
	c.JSON(http.StatusOK, getResponse(c, resp))
}

func update(c *gin.Context) {
	p := new(UpdateResp)
	if err := c.BindJSON(p); err != nil {
		c.JSON(http.StatusInternalServerError, err)
	}
	resp, err := apiUserSvc.Update(c, p)
	if err != nil {
		c.Set("code", -500)
		c.Set("message", err.Error())
		c.JSON(http.StatusOK, getResponse(c, nil))
	}
	c.JSON(http.StatusOK, getResponse(c, resp))
}

func RegisterUserUserGinServer(e *gin.Engine, server UserGinServer) {
	apiUserSvc = server
	e.Handle(HTTP_METGOD, PathUserLogin, login)
	e.Handle(HTTP_METGOD, PathUserLogout, logout)
	e.Handle(HTTP_METGOD, PathUserInfo, handleUserAuthMiddleware, info)
	e.Handle(HTTP_METGOD, PathUserUpdate, handleUserAuthMiddleware, update)
}

// 返回数据格式化
func getResponse(c *gin.Context, data interface{}) gin.H {
	responseData := make(map[string]interface{})
	code, ok := c.Get("code")
	if !ok {
		code = 0
	}
	msg, ok := c.Get("message")
	if !ok {
		msg = ""
	}
	responseData["code"] = code
	responseData["message"] = msg
	responseData["data"] = data
	return responseData
}

var (
	userAuthMiddleware []gin.HandlerFunc
)

func RegisterUserAuthMiddleware(f gin.HandlerFunc) {
	userAuthMiddleware = append(userAuthMiddleware, f)
}

func handleUserAuthMiddleware(c *gin.Context) {
	for _, middleware := range userAuthMiddleware {
		if c.IsAborted() {
			break
		}
		middleware(c)
	}
}

